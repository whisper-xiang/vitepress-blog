# 迭代

迭代指的是对一个集合（例如数组、对象、字符串、或其他可迭代对象）中的每个元素逐个进行访问和处理的过程。  
迭代可以通过多种方式实现，常见的迭代方式包括使用 for 循环、for...of 循环、for...in 循环，以及数组的内置方法如 forEach、map、filter 等等。
本文将总结常见的迭代方法及其实现。
![迭代方法](./img/spy_UKdTjLkgYVJG/1618834019885-b41a9b89-a821-4e26-8c30-c6af527dad0f-910277.png)

<!--
## 迭代器

迭代器是一种特殊的对象，它实现了两个方法：

1. next() 方法：返回一个对象，该对象包含两个属性：done 和 value。done 属性是一个布尔值，表示迭代是否完成；value 属性是迭代返回的下一个值。当 done 为 true 时，迭代结束。
2. return() 方法：结束迭代并返回一个值。

迭代器对象可以被用来遍历某些数据结构，如数组、Map、Set、字符串、TypedArray、arguments 对象等。

```javascript
const iterator = arr.values();

while (true) {
  const { done, value } = iterator.next();
  if (done) break;
  console.log(value);
}
```

## 迭代器协议

迭代器协议（Iterator protocol）是一种定义对象之间如何进行交流的协议。它规定了如何创建一个对象的迭代器，以及如何通过迭代器来访问对象的元素。

任何对象都可以实现迭代器协议，只要它定义了 next() 方法。next() 方法返回一个包含 done 和 value 属性的对象。done 属性是一个布尔值，表示迭代是否完成；value 属性是迭代返回的下一个值。当 done 为 true 时，迭代结束。

```javascript
const obj = {
  values: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
      arr: [1, 2, 3, 4, 5],
    };
  },
};

const iterator = obj.values();

while (true) {
  const { done, value } = iterator.next();
  if (done) break;
  console.log(value);
}
```

## 迭代器与生成器

迭代器与生成器是两种不同的概念。

- 迭代器是一种对象，它实现了 next() 方法，用来返回一个包含 done 和 value 属性的对象。
- 生成器是一种函数，它使用 yield 关键字来返回一个值，并且可以暂停执行并恢复执行。

生成器与迭代器的关系类似于函数与函数调用的关系。生成器可以被调用，返回一个迭代器对象。

```javascript
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const iterator = generator();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
console.log(iterator.next().value); // undefined
```

生成器与迭代器的区别在于：

- 生成器可以暂停执行并恢复执行，而迭代器只能一次性返回所有的值。
- 生成器可以返回任意类型的值，而迭代器只能返回可迭代的值。
- 生成器可以被暂停并恢复，而迭代器只能被遍历一次。


## 迭代器与 for...of 循环

for...of 循环是 ES6 引入的新语法，它可以用来遍历可迭代对象（包括数组、Map、Set、字符串、TypedArray、arguments 对象等）。

```javascript
const arr = [1, 2, 3, 4, 5];

for (const value of arr) {
  console.log(value);
}
```

for...of 循环会自动调用迭代器的 next() 方法，并在每次迭代时返回迭代器的 value 属性。

```javascript
const obj = {
  values: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
      arr: [1, 2, 3, 4, 5],
    };
  },
};

for (const value of obj.values()) {
  console.log(value);
}
```

for...of 循环与迭代器的关系类似于 for 循环与迭代器的关系。for...of 循环会自动调用迭代器的 next() 方法，并在每次迭代时返回迭代器的 value 属性。

## 迭代器与数组

数组的迭代器是 Array.prototype[Symbol.iterator]() 方法返回的迭代器。

```javascript
const arr = [1, 2, 3, 4, 5];

const iterator = arr[Symbol.iterator]();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
console.log(iterator.next().value); // 4
console.log(iterator.next().value); // 5
console.log(iterator.next().value); // undefined
```

数组的迭代器会一次性返回数组的所有元素。

```javascript
const obj = {
  values: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
      arr: [1, 2, 3, 4, 5],
    };
  },
};

for (const value of obj) {
  console.log(value);
}
```

for...of 循环会自动调用数组的迭代器的 next() 方法，并在每次迭代时返回迭代器的 value 属性。

## 迭代器与 Map

Map 的迭代器是 Map.prototype[Symbol.iterator]() 方法返回的迭代器。
Map 的迭代器会一次性返回 Map 的所有元素。

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
]);


for (const [key, value] of map) {
  console.log(key, value);
}
```

## 迭代器与 Set

Set 的迭代器是 Set.prototype[Symbol.iterator]() 方法返回的迭代器。
Set 的迭代器会一次性返回 Set 的所有元素。

```javascript
const set = new Set([1, 2, 3, 4, 5]);

for (const value of set) {
  console.log(value);
}
```

## 迭代器与字符串

字符串的迭代器是 String.prototype[Symbol.iterator]() 方法返回的迭代器。
字符串的迭代器会一次性返回字符串的所有字符。

```javascript
const str = 'hello world';

for (const char of str) {
  console.log(char);
}
```

## 迭代器与 TypedArray

TypedArray 的迭代器是 TypedArray.prototype[Symbol.iterator]() 方法返回的迭代器。
TypedArray 的迭代器会一次性返回 TypedArray 的所有元素。


```javascript
const arr = new Int32Array([1, 2, 3, 4, 5]);

for (const value of arr) {
  console.log(value);
}
```

## 迭代器与 arguments 对象

arguments 对象是函数调用时自动创建的对象。
arguments 对象没有迭代器，但是可以通过 Array.from() 方法将其转换为数组。

```javascript
function sum() {
  return Array.from(arguments).reduce((acc, cur) => acc + cur, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

## 迭代器与自定义对象

自定义对象如果想实现迭代器协议，需要定义一个 next() 方法，该方法返回一个包含 done 和 value 属性的对象。

```javascript
const obj = {
  values: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
      arr: [1, 2, 3, 4, 5],
    };
  },
};

const iterator = obj.values();

while (true) {
  const { done, value } = iterator.next();
  if (done) break;
  console.log(value);
}
```

## 迭代器与异步操作

异步操作（如 Promise、async/await）返回的迭代器只能被消费一次。

```javascript
const promise = new Promise((resolve) => {
  setTimeout(() => {
    resolve([1, 2, 3, 4, 5]);
  }, 1000);
});

promise.then((arr) => {
  for (const value of arr) {
    console.log(value);
  }
});
```

## 迭代器与性能

迭代器与数组、Map、Set、字符串、TypedArray、arguments 对象等的性能相当。
但是，对于自定义对象，如果没有实现迭代器协议，则无法使用 for...of 循环。
对于异步操作，迭代器只能被消费一次，因此无法使用 for...of 循环。
因此，在选择迭代器时，需要考虑性能、可读性、可维护性等因素。

## 迭代器与可迭代对象

可迭代对象（Iterable）是指可以被 for...of 循环遍历的对象。

```javascript
const arr = [1, 2, 3, 4, 5];
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
]);
const set = new Set([1, 2, 3, 4, 5]);
const str = 'hello world';
const arr2 = new Int32Array([1, 2, 3, 4, 5]);

for (const value of arr) {
  console.log(value);
}

for (const [key, value] of map) {
  console.log(key, value);
}

for (const value of set) {
  console.log(value);
}

for (const char of str) {
  console.log(char);
}

for (const value of arr2) {
  console.log(value);
}
```

## 迭代器与可迭代对象协议

可迭代对象协议（Iterable protocol）是一种定义对象是否可以被 for...of 循环遍历的协议。

任何对象都可以实现可迭代对象协议，只要它定义了 Symbol.iterator 方法。

```javascript
const obj = {
  [Symbol.iterator]: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
      arr: [1, 2, 3, 4, 5],
    };
  },
};

for (const value of obj) {
  console.log(value);
}
```

## 迭代器与可迭代对象协议的缺陷

可迭代对象协议的缺陷是无法判断对象是否可以被 for...of 循环遍历。

```javascript
const obj = {
  arr: [1, 2, 3, 4, 5],
};

for (const value of obj) {
  console.log(value);
}
```

上面的代码会报错，因为 obj 没有实现可迭代对象协议。

## 迭代器与可迭代对象协议的优点

可迭代对象协议的优点是可以统一所有可迭代对象，使得代码更加易读、易写。

```javascript
const arr = [1, 2, 3, 4, 5];
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
]);
const set = new Set([1, 2, 3, 4, 5]);
const str = 'hello world';
const arr2 = new Int32Array([1, 2, 3, 4, 5]);


for (const value of arr) {   // 统一的 for...of 循环
  console.log(value);
}

for (const [key, value] of map) {   // 统一的 for...of 循环
  console.log(key, value);
}

for (const value of set) {   // 统一的 for...of 循环
  console.log(value);
}


for (const char of str) {   // 统一的 for...of 循环
  console.log(char);
}

for (const value of arr2) {   // 统一的 for...of 循环
  console.log(value);
}
```

## 迭代器与可迭代对象协议的实现

可迭代对象协议的实现方法有两种：

1. 实现 Symbol.iterator 方法
2. 实现 @@iterator 方法

```javascript
const obj = {
  arr: [1, 2, 3, 4, 5],
  [Symbol.iterator]: function () {
    let index = 0;
    return {
      next: function () {
        if (index < this.arr.length) {
          return { done: false, value: this.arr[index++] };
        } else {
          return { done: true, value: undefined };
        }
      },
    };
  },
};

for (const value of obj) {
  console.log(value); // 1, 2, 3, 4, 5
}
```


 -->

## 1. for 循环

### 1.1 基础用法

```javascript
// 格式：
for ([initialization]; [condition]; [final - expression]) statement
```

- `initialization` 表示一个表达式 (包含赋值语句) 或者变量声明。被用于初始化一个计数器。
- `condition` 表示一个表达式，在每次循环迭代之前被求值。如果该表达式的值为 true，则执行循环体，否则跳过循环体。
- `final-expression` 表示一个表达式，在每次循环迭代之后被求值。该表达式的值不会被使用。
- `statement` 表示一个或多个语句，在每次循环迭代时被执行。

```javascript
// 示例
for (var i = 0; i < 5; i++) {
  console.log(i)
}
```

### 1.2 循环退出

循环退出有三种方式:

- `break` 语句: 立即退出循环，不再执行循环体后面的语句。
- `continue` 语句: 立即结束本次循环迭代，开始下一次循环迭代。
- `return` 语句: 立即退出循环并返回一个值。

`continue` 用于退出本次循环，`break` 用于退出整个循环，这两个语句可以指定 `label` 从而可以退出特定的循环。

```javascript
var num = 0
outermost: for (var i = 0; i < 10; i++) {
  for (var j = 0; j < 10; j++) {
    if (i == 5 && j == 5) {
      break outermost
    }
    num++
  }
}
alert(num) //55

var num = 0
outermost: for (var i = 0; i < 10; i++) {
  for (var j = 0; j < 10; j++) {
    if (i == 5 && j == 5) {
      continue outermost
    }
    num++
  }
}
alert(num) //45
```

`return` 直接跳出整个循环。 与 `return` 不同的是，在**多层循环中**，`break` 不是跳出函数，而是跳出最里层的 `for` 循环，外面的循环和最外层 `for` 循环后面的语句也将继续执行。

```javascript
function count() {
  for (var i = 0; i < 5; i++) {
    for (var j = 0; j < 5; j++) {
      if (i == 2 && j == 2) {
        return i * j
      }
    }
  }
}
console.log(count()) // 4

function count() {
  for (var i = 0; i < 5; i++) {
    for (var j = 0; j < 5; j++) {
      if (i == 2 && j == 2) {
        break
      }
    }
  }
  return i * j
}
console.log(count()) // 25
```

## 2. forEach

```javascript
arr.forEach(function(currentValue, index, arr), thisArg)
```

`function(currentValue, index, arr)` 是一个回调函数，其中 `currentValue` 是数组中正在处理的当前元素，`index` 是当前元素的索引，`arr` 是数组本身。

- `thisArg` (可选) 指定 `this` 对象的上下文。

### 2.1 基础用法

#### 2.1.1 遍历范围

- 遍历的范围在第一次调用 ` callback ` 前就会确定。调用 ` forEach ` 后添加到数组中的项不会被 ` callback ` 访问到。
- `forEach` 不会直接改变调用它的对象，但是那个对象可能会被 ` callback ` 函数改变。

```javascript
var arr = [1, 2, 3, 4, 5]
arr.forEach(function (currentValue, index, arr) {
  console.log(currentValue)
})
// output: 1, 2, 3, 4, 5

var arr = [1, 2, 3, 4, 5]
arr.forEach(function (currentValue, index, arr) {
  console.log(currentValue) // 输出 1, 2, 3, 4, 5
  currentValue === 1 && arr.push(6)
})
console.log(arr) // output: [1, 2, 3, 4, 5, 6] (原数组已被更改，但第 6 项不会被遍历到)

var arr = [1, 2, 3, 4, 5]

arr.forEach(function (currentValue, index, array) {
  if (index === 2) {
    array[index] = 10 // 修改当前元素
    array[index + 1] = 20 // 修改下一个元素
  }
  console.log(currentValue)
})
// 依次输出1, 2, 3, 20, 5
```

#### 2.1.2 循环退出

`forEach` 循环中 `return、return true、return false` 只能跳出本次循环，不能跳出整个循环

```javascript
;[1, 2, 3, 4, 5].forEach((item) => {
  if (item === 2) return
  console.log(item)
})
// output 1,3,4,5
```

#### 2.1.3 稀疏数组处理

在 `forEach` 方法中，稀疏数组（即存在未初始化或空槽的数组）中的未初始化元素不会被 `callback` 函数访问或处理。

```javascript
var arr = [1, , 3, , 5]

arr.forEach(function (value, index) {
  console.log('Index:', index, 'Value:', value)
})
// Index: 0 Value: 1
// Index: 2 Value: 3
// Index: 4 Value: 5
```

#### 2.1.4 thisArg

```javascript
function Logger() {
  this.prefix = 'Item: ';
}

Logger.prototype.log = function(element) {
  console.log(this.prefix + element);
};

const logger = new Logger();
const arr = ['a', 'b', 'c'];

arr.forEach(function(element) {
    this.log(element);
  }, logger);
}
// output: Item: a, Item: b, Item: c
```

因为  `thisArg`  参数作为`（this）`传给了  `forEach()`，每次调用时，它都被传给 `callback`  函数，作为它的  `this`  值。   
在上面的例子中，由于 `thisArg` 被设置为 `logger` 实例，`this.log(element)` 调用的 `log` 方法的 `this` 是 `logger` 实例，因此会输出 `'Item: a', 'Item: b', 'Item: c'`。

::: warning 注意
箭头函数不会绑定自己的 this 值，而是从外部上下文继承 this。如果使用箭头函数，thisArg 参数将被忽略：

```javascript
const obj = {
  value: 42,
  log: function (element) {
    console.log(this.value + element)
  },
}

const arr = [1, 2, 3]

arr.forEach((element) => {
  this.log(element) // 注意：`this` 不会被绑定到 `obj`
}, obj)
```

:::

### 2.2 使用方式拓展

#### 2.2.1 如果数组在迭代时被修改了，则其他元素会被跳过。

`forEach()` 不会在迭代之前创建数组的副本。

下面的例子会输出` "one", "two", "four"`。当到达包含值 `"two"` 的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 `"four" `正位于在数组更前的位置，所以 `"three"` 会被跳过。

```javascript
var words = ['one', 'two', 'three', 'four']
words.forEach(function (word) {
  console.log(word)
  if (word === 'two') {
    words.shift()
  }
})
// one
// two
// four
```

#### 2.2.2 扁平化数组

下面的示例仅用于学习目的。如果你想使用内置方法来扁平化数组，你可以考虑使用 [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat).

```javascript
/**
 * Flattens passed array in one dimensional array
 *
 * @params {array} arr
 * @returns {array}
 */
function flatten(arr) {
  const result = []
  arr.forEach((i) => {
    if (Array.isArray(i)) result.push(...flatten(i))
    else result.push(i)
  })
  return result
}
// Usage
const problem = [1, 2, 3, [4, 5, [6, 7], 8, 9]]
flatten(problem) // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 2.2.3 通过抛出异常的方式跳出整个循环

```javascript
try {
  var array = ['1', '2', '3', '4']
  // 执行到第3次，结束循环
  array.forEach(function (item, index) {
    if (index === 2) {
      throw new Error('EndIterative')
    }
    console.log(item)
  })
} catch (e) {
  if (e.message != 'EndIterative') throw e
}
// 下面的代码不影响继续执行
console.log('5')
// output: 1, 2, 5
```

## 3. map

`map()`方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```javascript
 var new_array = arr.map(function callback(currentValue[, index[, array]]) {
  // return element for new_array
 }[, thisArg])
```

- 回调函数可以接受三个参数：当前元素的值、当前元素的索引（可选）、原数组（可选）。
- 如果没有提供 thisArg，则 this 绑定到全局对象。
- 同 `forEach` 一样， `callback` 函数只会在有值的索引上被调用。

## 4. every

`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，返回一个布尔值。

- `every` 遍历的元素范围在第一次调用 `callback`  之前就已确定了。在调用  `every` 之后添加到数组中的元素不会被  `callback`  访问到。
- 如果数组中存在的元素被更改，则他们传入  `callback`  的值是  `every`  访问到他们那一刻的值。
- 那些被删除的元素或从来未被赋值的元素将不会被访问到。

```javascript
var a = [1, 2, 3, 4].every(function (item, i) {
  return item < 3
})
// 4 > 3 所以 a 值为 false
```

在 `every callback` 函数体内，`return false` 跳出整个循环，而`return true` 则会跳出本次循环，继续下一轮循环；

## 5. some

`some()` 方法测试数组中是否至少有一个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。

```javascript
  arr.some(callback(element[, index[, array]])[, thisArg])
```

- `some()`  遍历的元素的范围在第一次调用  `callback` 前就已经确定了。
- 在调用  `some()`  后被添加到数组中的值不会被  `callback`  访问到。
- 如果数组中存在且还未被访问到的元素被  `callback`  改变了，则其传递给  `callback`  的值是  `some()`  访问到它那一刻的值。已经被删除的元素不会被访问到。

### 5.1 拓展使用

#### 5.1.1 将任意值转换为布尔类型

```javascript
var TRUTHY_VALUES = [true, 'true', 1]
function getBoolean(value) {
  'use strict'
  if (typeof value === 'string') {
    value = value.toLowerCase().trim()
  }
  return TRUTHY_VALUES.some(function (t) {
    return t === value
  })
}
getBoolean(false) // false
getBoolean('false') // false
getBoolean(1) // true
getBoolean('true') // true
```

## 6. filter

`filter()` 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。

```javascript
arr.filter(callback(element[, index[, array]])[, thisArg])
```

- filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。
- 在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。
- 如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。

## 7. reduce()

`reduce()` 方法对数组中的每个元素执行一个由您提供的 reducer 函数（升序执行），将其结果汇总为单个返回值。

```javascript
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
```

`callback` 执行数组中每个值(如果没有提供 `initialValue` 则第一个值除外)的函数，包含四个参数：

- `accumulator`: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或 `initialValue`（见于下方）。
- `currentValue`: 数组中正在处理的元素。
- `index`: (可选) 数组中正在处理的当前元素的索引。 如果提供了 `initialValue`，则起始索引号为 0，否则从索引 1 起始。
- `array`: (可选) 调用 `reduce()` 的数组 `initialValue` 可选作为第一次调用 `callback` 函数时的第一个参数的值。

如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。
如果没有提供 `initialValue`，reduce 会从索引 **1** 的地方开始执行 `callback` 方法，跳过第一个索引。如果提供 `initialValue`，从索引** 0** 开始。

### 7.1 拓展使用

### 7.1.1 将二维数组转化为一维

```javascript
var flattened = [
  [0, 1],
  [2, 3],
  [4, 5],
].reduce((acc, cur) => acc.concat(cur), [])
```

### 7.1.2 按属性对 object 分类

```javascript
var people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 },
]

function groupBy(objectArray, property) {
  return objectArray.reduce(function (acc, obj) {
    var key = obj[property]
    if (!acc[key]) {
      acc[key] = []
    }
    acc[key].push(obj)
    return acc
  }, {})
}

var groupedPeople = groupBy(people, 'age')
// groupedPeople is:
// {
//   20: [
//     { name: 'Max', age: 20 },
//     { name: 'Jane', age: 20 }
//   ],
//   21: [{ name: 'Alice', age: 21 }]
// }
```

### 7.1.3 数组去重

```javascript
let arr = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
let result = arr.sort().reduce((init, current) => {
  if (init.length === 0 || init[init.length - 1] !== current) {
    init.push(current)
  }
  return init
}, [])
console.log(result) //[1,2,3,4,5]
```

### 7.1.4 按顺序运行 Promise

```javascript
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input),
  )
}

// promise function 1
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5)
  })
}

// promise function 2
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2)
  })
}

// function 3  - will be wrapped in a resolved promise by .then()
function f3(a) {
  return a * 3
}

// promise function 4
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4)
  })
}

const promiseArr = [p1, p2, f3, p4]
runPromiseInSequence(promiseArr, 10).then(console.log) // 1200
```

### 7.1.5 使用  reduce 实现 map

```javascript
if (!Array.prototype.mapUsingReduce) {
  Array.prototype.mapUsingReduce = function (callback, thisArg) {
    return this.reduce(function (mappedArray, currentValue, index, array) {
      mappedArray[index] = callback.call(thisArg, currentValue, index, array)
      return mappedArray
    }, [])
  }
}
;[1, 2, , 3].mapUsingReduce((currentValue, index, array) => currentValue + index + array.length) // [5, 7, , 10]
```

---

## 8. reduceRight()

> arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])

### 8.1 运行一个带有回调每个函数将其结果传给下一个的异步函数列表

```javascript
const waterfall =
  (...functions) =>
  (callback, ...args) =>
    functions.reduceRight(
      (composition, fn) =>
        (...results) =>
          fn(composition, ...results),
      callback,
    )(...args)
const randInt = (max) => Math.floor(Math.random() * max)
const add5 = (callback, x) => {
  setTimeout(callback, randInt(1000), x + 5)
}
const mult3 = (callback, x) => {
  setTimeout(callback, randInt(1000), x * 3)
}
const sub2 = (callback, x) => {
  setTimeout(callback, randInt(1000), x - 2)
}
const split = (callback, x) => {
  setTimeout(callback, randInt(1000), x, x)
}
const add = (callback, x, y) => {
  setTimeout(callback, randInt(1000), x + y)
}
const div4 = (callback, x) => {
  setTimeout(callback, randInt(1000), x / 4)
}
const computation = waterfall(add5, mult3, sub2, split, add, div4)
computation(console.log, 5) // -> 14
// same as:
const computation2 = (input, callback) => {
  const f6 = (x) => div4(callback, x)
  const f5 = (x, y) => add(f6, x, y)
  const f4 = (x) => split(f5, x)
  const f3 = (x) => sub2(f4, x)
  const f2 = (x) => mult3(f3, x)
  add5(f2, input)
}
```

### 8.2 定义可组合函数

组合函数的概念简单，它只是简单地结合了多个函数。它是一个从右向左流动的函数，用上一个函数的输出调用每个函数。

```javascript
/**
 * Function Composition is way in which result of one function can
 * be passed to another and so on.
 *
 * h(x) = f(g(x))
 *
 * Function execution happens right to left
 *
 * https://en.wikipedia.org/wiki/Function_composition
 */
const compose =
  (...args) =>
  (value) =>
    args.reduceRight((acc, fn) => fn(acc), value)
// Increament passed number
const inc = (n) => n + 1
// Doubles the passed value
const double = (n) => n * 2
// using composition function
console.log(compose(double, inc)(2)) // 6
// using composition function
console.log(compose(inc, double)(2)) // 5
```

## 9. for...in

`**for...in**`**语句**以任意顺序遍历一个对象的除[Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性。

### 9.1 仅迭代自身的属性

如果你只要考虑对象本身的属性，而不是它的原型，那么使用 `getOwnPropertyNames()` 或执行 `hasOwnProperty()` 来确定某属性是否是对象本身的属性（也能使用`propertyIsEnumerable`）。或者，如果你知道不会有任何外部代码干扰，您可以使用检查方法扩展内置原型。

## 10. for...of

`**for...of**`**语句**在[可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)（包括  `[Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)`，`[Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)`，`[Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)`，`[String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)`，`[TypedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)`，[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments)  对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。

```javascript
let iterable = [10, 20, 30]
for (let value of iterable) {
  value += 1
  console.log(value)
}
// 11
// 21
// 31
;(iterable) => [10, 20, 30]

value为浅拷贝
```

### 10.2 与 for in 比较

无论是`for...in`还是`for...of`语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
`[for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)` 语句以任意顺序迭代对象的[可枚举属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。
`for...of` 语句遍历[可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterables)定义要迭代的数据。
以下示例显示了与`[Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)`一起使用时，`for...of`循环和`for...in`循环之间的区别。

```javascript
Object.prototype.objCustom = function () {}
Array.prototype.arrCustom = function () {}
let iterable = [3, 5, 7]
iterable.foo = 'hello'
for (let i in iterable) {
  console.log(i) // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}
for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i) // logs 0, 1, 2, "foo"
  }
}
for (let i of iterable) {
  console.log(i) // logs 3, 5, 7
}
```

## 11. find

```
arr.find(callback[, thisArg])
```

数组中第一个满足所提供测试函数的元素的值，否则返回  `[undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)`。
注意 `callback `函数会为数组中的每个索引调用即从 `0 `到 `length - 1`，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。

如果数组中一个尚未被`callback`函数访问到的元素的值被`callback`函数所改变，那么当`callback`函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到，但是其值已经是 undefined 了。

如果数组中一个尚未被`callback`函数访问到的元素的值被`callback`函数所改变，那么当`callback`函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍然会被访问到。

## 12. findIndex

它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍然会被访问到。

## 13. entries

## 14. keys()

`**keys() **`方法返回一个包含数组中每个索引键的`**Array Iterator**`对象。

```javascript
var arr = ['a', , 'c']
var sparseKeys = Object.keys(arr)
var denseKeys = [...arr.keys()]
console.log(sparseKeys) // ['0', '2']
console.log(denseKeys) // [0, 1, 2]
```

## 15. values()

`**values()**`  方法返回一个新的  `**Array Iterator**`  对象，该对象包含数组每个索引的值

**Array.prototype.values** 是 **Array.prototype[Symbol.iterator] **的默认实现。
Array.prototype.values === Array.prototype[Symbol.iterator]  // true

**值**: 数组迭代器中存储的是原数组的地址，而不是数组元素值。

```javascript
var arr = ['a', 'b', 'c', 'd', 'e']
var iterator = arr.values()
console.log(iterator) // Array Iterator {  }
iterator.next().value // "a"
arr[1] = 'n'
iterator.next().value //  "n"
```

如果数组中元素改变，那么迭代器的值也会改变

## 17. Symbol.iterator

**Symbol.iterator **为每一个对象定义了默认的迭代器。该迭代器可以被 `[for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)` 循环使用。
当需要对一个对象进行迭代时（比如开始用于一个`for..of`循环中），它的`@@iterator`方法都会在不传参情况下被调用，返回的**迭代器**用于获取要迭代的值。

### 17.1 自定义迭代器

我们可以像下面这样创建自定义的迭代器：

```javascript
var myIterable = {}
myIterable[Symbol.iterator] = function* () {
  yield 1
  yield 2
  yield 3
}
;[...myIterable] // [1, 2, 3]
```
